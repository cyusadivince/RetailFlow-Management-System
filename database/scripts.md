##tables creations

1. CUSTOMER Table
```
CREATE TABLE Customer (
  CustomerID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  FullName VARCHAR2(100) NOT NULL,
  Email VARCHAR2(100) UNIQUE NOT NULL,
  Password VARCHAR2(100) NOT NULL,
  Phone VARCHAR2(20) UNIQUE,
  Address VARCHAR2(255),
  CONSTRAINT chk_phone CHECK (REGEXP_LIKE(Phone, '^[0-9]+$'))
);

```
2. Category Table
```
CREATE TABLE Category (
  CategoryID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  CategoryName VARCHAR2(50) NOT NULL UNIQUE
);
```
3. Product Table
```
CREATE TABLE Product (
  ProductID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  Name VARCHAR2(100) NOT NULL,
  Description VARCHAR2(255),
  Price NUMBER(10,2) NOT NULL CHECK (Price >= 0),
  StockQty NUMBER DEFAULT 0 CHECK (StockQty >= 0),
  CategoryID NUMBER NOT NULL,
  CONSTRAINT fk_category FOREIGN KEY (CategoryID)
      REFERENCES Category(CategoryID)
);
```
4. Orders Table

```
CREATE TABLE Orders (
  OrderID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  CustomerID NUMBER NOT NULL,
  OrderDate DATE DEFAULT SYSDATE,
  TotalAmount NUMBER(10,2) CHECK (TotalAmount >= 0),
  Status VARCHAR2(20) DEFAULT 'Pending',
  CONSTRAINT fk_customer FOREIGN KEY (CustomerID)
      REFERENCES Customer(CustomerID)
);
```
5. Orders_Item Table
```
CREATE TABLE OrderItem (
  OrderItemID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  OrderID NUMBER NOT NULL,
  ProductID NUMBER NOT NULL,
  Quantity NUMBER CHECK (Quantity > 0),
  Subtotal NUMBER(10,2) CHECK (Subtotal >= 0),
  CONSTRAINT fk_order FOREIGN KEY (OrderID)
      REFERENCES Orders(OrderID)
      ON DELETE CASCADE,
  CONSTRAINT fk_product FOREIGN KEY (ProductID)
      REFERENCES Product(ProductID)
);

```

6. Payment Table
```
`CREATE TABLE Payment (
  PaymentID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  OrderID NUMBER NOT NULL,
  PaymentDate DATE DEFAULT SYSDATE,
  Amount NUMBER(10,2) NOT NULL CHECK (Amount >= 0),
  PaymentMethod VARCHAR2(50) NOT NULL,
  CONSTRAINT fk_payment_order FOREIGN KEY (OrderID)
      REFERENCES Orders(OrderID)
);
```
7. Delivery

```
CREATE TABLE Delivery (
  DeliveryID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  OrderID NUMBER NOT NULL,
  DeliveryDate DATE,
  DeliveryStatus VARCHAR2(50) DEFAULT 'Pending',
  CONSTRAINT fk_delivery_order FOREIGN KEY (OrderID)
      REFERENCES Orders(OrderID)
);
```
8. Holiday Table

```
CREATE TABLE Holiday (
  HolidayDate DATE PRIMARY KEY,
  Description VARCHAR2(100) NOT NULL
);
```

9. Audit_Log Table

```
CREATE TABLE Audit_Log (
  LogID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  UserID VARCHAR2(50) NOT NULL,
  ActionDate DATE DEFAULT SYSDATE,
  TableName VARCHAR2(50),
  Operation VARCHAR2(10),
  Status VARCHAR2(10)
);
```
Sample Data insertion into Tables

```
INSERT INTO Customer (FullName, Email, Password, Phone, Address)
VALUES ('Alice Smith', 'alice@example.com', 'pass123', '0788888888', 'Kigali');

INSERT INTO Customer (FullName, Email, Password, Phone, Address)
VALUES ('John Doe', 'john@example.com', 'secure456', '0788777788', 'Huye');

INSERT INTO Category (CategoryName) VALUES ('Electronics');
INSERT INTO Category (CategoryName) VALUES ('Clothing');

INSERT INTO Product (Name, Description, Price, StockQty, CategoryID)
VALUES ('HP Laptop', '14-inch EliteBook', 1200.00, 10, 1);

INSERT INTO Product (Name, Description, Price, StockQty, CategoryID)
VALUES ('T-Shirt', 'Cotton white T-shirt', 20.00, 50, 2);

INSERT INTO Holiday VALUES (TO_DATE('2025-06-01','YYYY-MM-DD'), 'Independence Day');

```

Package Specification 
```
CREATE OR REPLACE PACKAGE ecommerce_pkg AS

  -- CUSTOM EXCEPTIONS
  ex_invalid_customer EXCEPTION;
  ex_invalid_product  EXCEPTION;
  ex_invalid_quantity EXCEPTION;
  ex_no_stock         EXCEPTION;

  -- PROCEDURES

  -- 1. Update Product Price
  PROCEDURE update_product_price (
    p_product_id IN NUMBER,
    p_new_price  IN NUMBER
  );

  -- 2. Bulk Price Increase
  PROCEDURE bulk_increase_price (
    p_percent IN NUMBER
  );

  -- FUNCTIONS

  -- 1. Total spent by customer
  FUNCTION get_total_spent (
    p_customer_id IN NUMBER
  ) RETURN NUMBER;

  -- 2. Product exists
  FUNCTION product_exists (
    p_product_id IN NUMBER
  ) RETURN BOOLEAN;

  -- 3. Customer exists
  FUNCTION customer_exists (
    p_customer_id IN NUMBER
  ) RETURN BOOLEAN;

  -- 4. Get pending orders
  FUNCTION get_pending_orders RETURN SYS_REFCURSOR;

  -- 5. Rank customers
  FUNCTION customer_rank RETURN SYS_REFCURSOR;

END ecommerce_pkg;
/

```
Package Body

```
CREATE OR REPLACE PACKAGE BODY ecommerce_pkg AS

  -- =========================
  -- VALIDATION FUNCTIONS
  -- =========================

  FUNCTION customer_exists (p_customer_id NUMBER) RETURN BOOLEAN IS
    v_count NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM customer 
    WHERE customerid = p_customer_id;
    RETURN (v_count > 0);
  END customer_exists;

  FUNCTION product_exists (p_product_id NUMBER) RETURN BOOLEAN IS
    v_count NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM product 
    WHERE productid = p_product_id;
    RETURN (v_count > 0);
  END product_exists;

  -- =========================
  -- UPDATE PRODUCT PRICE
  -- =========================
  PROCEDURE update_product_price (
    p_product_id IN NUMBER,
    p_new_price  IN NUMBER
  ) IS
  BEGIN
    IF NOT product_exists(p_product_id) THEN
      RAISE ex_invalid_product;
    END IF;

    UPDATE product
    SET price = p_new_price
    WHERE productid = p_product_id;

    COMMIT;

  EXCEPTION
    WHEN ex_invalid_product THEN
      RAISE_APPLICATION_ERROR(-20010, 'Product not found');
    WHEN OTHERS THEN
      ROLLBACK;
      RAISE;
  END update_product_price;

  -- =========================
  -- BULK PRICE INCREASE
  -- =========================
  PROCEDURE bulk_increase_price (p_percent NUMBER) IS
    TYPE prod_tab IS TABLE OF product.productid%TYPE;
    v_ids prod_tab;
  BEGIN
    SELECT productid BULK COLLECT INTO v_ids FROM product;

    FORALL i IN 1..v_ids.COUNT
      UPDATE product
      SET price = price + (price * p_percent / 100)
      WHERE productid = v_ids(i);

    COMMIT;
  END bulk_increase_price;

  -- =========================
  -- TOTAL SPENT
  -- =========================
  FUNCTION get_total_spent (p_customer_id NUMBER) RETURN NUMBER IS
    v_total NUMBER;
  BEGIN
    SELECT NVL(SUM(totalamount),0) INTO v_total
    FROM orders
    WHERE customerid = p_customer_id;

    RETURN v_total;
  END get_total_spent;

  -- =========================
  -- GET PENDING ORDERS
  -- =========================
  FUNCTION get_pending_orders RETURN SYS_REFCURSOR IS
    rc SYS_REFCURSOR;
  BEGIN
    OPEN rc FOR
      SELECT *
      FROM orders
      WHERE status = 'Pending';
    RETURN rc;
  END get_pending_orders;

  -- =========================
  -- CUSTOMER RANK
  -- =========================
  FUNCTION customer_rank RETURN SYS_REFCURSOR IS
    rc SYS_REFCURSOR;
  BEGIN
    OPEN rc FOR
      SELECT customerid,
             SUM(totalamount) AS total,
             RANK() OVER(ORDER BY SUM(totalamount) DESC) AS rank
      FROM orders
      GROUP BY customerid;
    RETURN rc;
  END customer_rank;

END ecommerce_pkg;
/

```

Testing codes for our functions and cursors as well as Procedures
```
SET SERVEROUTPUT ON;

DECLARE
  v_exists BOOLEAN;
BEGIN
  v_exists := ecommerce_pkg.customer_exists(1);
  IF v_exists THEN
    DBMS_OUTPUT.PUT_LINE('Customer exists');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Customer does not exist');
  END IF;

--Testing If Product exist or not

  v_exists := ecommerce_pkg.product_exists(101);
  IF v_exists THEN
    DBMS_OUTPUT.PUT_LINE('Product exists');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Product does not exist');
  END IF;
END;
/

```
Update Single Product price

```
BEGIN
  ecommerce_pkg.update_product_price(101, 150);
END;
/

-- Bulk increase prices by 10%
BEGIN
  ecommerce_pkg.bulk_increase_price(10);
END;
/
```

Get Customer Rank Based on his Amount spent

```
VAR rc REFCURSOR

EXEC :rc := ecommerce_pkg.get_pending_orders;

PRINT rc;



VAR rc REFCURSOR

EXEC :rc := ecommerce_pkg.customer_rank;

PRINT rc;
```


Other Created Functions outside the Package

```
--Stock Check Availability

CREATE OR REPLACE FUNCTION check_stock_status (
  p_product_id IN NUMBER
) RETURN VARCHAR2
IS
  v_stock NUMBER;
BEGIN
  SELECT stockqty
  INTO v_stock
  FROM product
  WHERE productid = p_product_id;

  IF v_stock = 0 THEN
    RETURN 'Out of Stock';
  ELSIF v_stock BETWEEN 1 AND 5 THEN
    RETURN 'Low Stock';
  ELSE
    RETURN 'In Stock';
  END IF;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN 'Product not found';
END;
/
```


--Get Total Sales By Date Range
```
CREATE OR REPLACE FUNCTION get_total_sales_by_date (
  p_start_date IN DATE,
  p_end_date   IN DATE
) RETURN NUMBER
IS
  v_total NUMBER;
BEGIN
  SELECT NVL(SUM(totalamount), 0)
  INTO v_total
  FROM orders
  WHERE orderdate BETWEEN p_start_date AND p_end_date
  AND status = 'Completed';

  RETURN v_total;
END;
/
```

Get Total sales By date testing code
```
SET SERVEROUTPUT ON;

DECLARE
    v_total NUMBER;
BEGIN
    v_total := get_total_sales_by_date(
                    TO_DATE('2025-01-01','YYYY-MM-DD'),
                    TO_DATE('2025-12-31','YYYY-MM-DD')
                );

    DBMS_OUTPUT.PUT_LINE('Total Sales = ' || v_total);
END;
/

```
Trigggers To restrict DML operation in week-day
```
CREATE OR REPLACE TRIGGER trg_restrict_product_dml
BEFORE INSERT OR UPDATE OR DELETE ON Product
FOR EACH ROW
DECLARE
  PRAGMA AUTONOMOUS_TRANSACTION;

  v_holiday_count NUMBER;
  v_operation     VARCHAR2(10);
  v_day           NUMBER;
BEGIN
  -- Detect operation
  IF INSERTING THEN
    v_operation := 'INSERT';
  ELSIF UPDATING THEN
    v_operation := 'UPDATE';
  ELSIF DELETING THEN
    v_operation := 'DELETE';
  END IF;

  -- Get day of week (1=Sunday,7=Saturday in default)
  v_day := TO_NUMBER(TO_CHAR(SYSDATE,'D'));

  -- Check if it's a holiday
  SELECT COUNT(*)
  INTO v_holiday_count
  FROM Holiday
  WHERE HolidayDate = TRUNC(SYSDATE);


  -- Weekday OR Holiday

   IF (v_day NOT IN (1,7)) OR (v_holiday_count > 0) THEN

    INSERT INTO Audit_Log
      (UserID, ActionDate, TableName, Operation, Status)
    VALUES
      (SYS_CONTEXT('USERENV','CURRENT_USER'),
       SYSDATE,
       'PRODUCT',
       v_operation,
       'DENIED');

    COMMIT;

    RAISE_APPLICATION_ERROR(
      -20001,
      'DML on PRODUCT is only allowed on weekends and not on holidays.'
    );


  -- ALLOW: Weekend AND not Holiday

   ELSE

    INSERT INTO Audit_Log
      (UserID, ActionDate, TableName, Operation, Status)
    VALUES
      (SYS_CONTEXT('USERENV','CURRENT_USER'),
       SYSDATE,
       'PRODUCT',
       v_operation,
       'ALLOWED');

    COMMIT;

  END IF;

END;
/
```

Test Trigger

```
update product set price=2 where productid=9;
```
Other Queries and Subqueries Done

```
--Total sales per product
SELECT
    p.productid,
    p.name,
    SUM(oi.quantity) AS total_units_sold,
    SUM(oi.subtotal) AS total_sales
FROM product p
JOIN orderitem oi ON p.productid = oi.productid
GROUP BY p.productid, p.name;

```

Total Spent By-Customers
```
--Total_Spent_By_Customer
SELECT 
    customerid,
    SUM(totalamount) AS total_spent
FROM orders
GROUP BY customerid;
```

Customer who spent more than Average
```
SELECT customerid, fullname
FROM customer
WHERE customerid IN (
    SELECT customerid
    FROM orders
    GROUP BY customerid
    HAVING SUM(totalamount) >
        (SELECT AVG(totalamount) FROM orders)
);
```

Placing Order Procedure

```

CREATE OR REPLACE PROCEDURE place_order(
    p_customer_id   IN NUMBER,
    p_product_id    IN NUMBER,
    p_quantity      IN NUMBER
)
IS
    v_stock     NUMBER;
    v_price     NUMBER;
    v_order_id  NUMBER;
BEGIN
    -- 1. Check customer exists
    IF NOT ecommerce_pkg.customer_exists(p_customer_id) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Customer does not exist');
    END IF;

    -- 2. Check product exists
    IF NOT ecommerce_pkg.product_exists(p_product_id) THEN
        RAISE_APPLICATION_ERROR(-20002, 'Product does not exist');
    END IF;

    -- 3. Get stock & price
    SELECT stockqty, price
    INTO v_stock, v_price
    FROM product
    WHERE productid = p_product_id
    FOR UPDATE;

    -- 4. Validate quantity
    IF p_quantity <= 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'Invalid quantity');
    END IF;

    IF v_stock < p_quantity THEN
        RAISE_APPLICATION_ERROR(-20004, 'Not enough stock');
    END IF;

    -- 5. Create order
    INSERT INTO orders (orderid, customerid, orderdate, status, totalamount)
    VALUES (orders_seq.NEXTVAL, p_customer_id, SYSDATE, 'Pending', p_quantity * v_price)
    RETURNING orderid INTO v_order_id;

    -- 6. Add order item
    INSERT INTO orderitem (orderid, productid, quantity, subtotal)
    VALUES (v_order_id, p_product_id, p_quantity, v_price);

    -- 7. Reduce stock
    UPDATE product
    SET stockqty = stockqty - p_quantity
    WHERE productid = p_product_id;

    COMMIT;

    DBMS_OUTPUT.PUT_LINE('Order placed successfully. Order ID = ' || v_order_id);

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END place_order;
/
```
Testing Place Order Procedure

```
-- customerid,productid,productQty

SET SERVEROUTPUT ON
BEGIN
  place_order(5, 4, 15);
END;
/
```

